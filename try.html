<!DOCTYPE html>
<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script>
			//创建场景
			var scene = new THREE.Scene();
			//摄像头，第一个属性是视野，第二个是宽高比，接下来的两个属性是近和远的裁剪平面。这意味着远离摄像头的物体远远比近的物体不会被渲染。
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			//渲染器
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			//如果您希望保持应用程序的大小，但是以较低的分辨率呈现，那么可以通过调用setSize（false）作为updateStyle（第三个参数）来实现。例如，setSize（window.innerWidth / 2，window.innerHeight / 2，false）将以半分辨率渲染您的应用程序
			document.body.appendChild( renderer.domElement );

			var geometry = new THREE.BoxGeometry( 1, 1, 1 );
			//要创建多维数据集，我们需要一个BoxGeometry。这是一个包含多维数据集的所有点（顶点）和填充（面）的对象
			var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			//除了几何，我们需要一种材料来对其进行着色。Three.js有几种材料，但现在我们将坚持使用MeshBasicMaterial。所有材料都具有将要应用于其的属性对象。为了保持简单，我们只提供一个颜色属性0x00ff00，它是绿色的。它的工作原理与CSS或Photoshop（十六进制颜色）中的颜色相同。
			var cube = new THREE.Mesh( geometry, material );
			//我们需要的第三件事就是网格。网格是一个对象，它接受一个几何体，然后应用一个材质，然后我们可以插入到我们的场景中，并且可以自由移动。
			scene.add( cube );
			camera.position.z = 5;
			//默认情况下，当我们调用scene.add（）时，我们添加的东西将被添加到坐标（0,0,0）中。这将导致相机和多维数据集彼此在一起。为了避免这种情况，我们只需将相机移出一点。
			var animate = function () {
				requestAnimationFrame( animate );

				cube.rotation.x += 0.01;
				cube.rotation.y += 0.01;

				renderer.render(scene, camera);
			};
			/*
			 * function animate() {
					requestAnimationFrame( animate );
					renderer.render( scene, camera );
				}
				animate();
				这将创建一个循环，使渲染器每秒画画60次。
				requestAnimationFrame有很多优点，也许最重要的是它暂停当用户浏览到另一个浏览器标签时，因此不会浪费宝贵的处理能力和电池寿命。
				在您的动画功能中的renderer.render调用上方添加以下权限：
				cube.rotation.x += 0.1;
				cube.rotation.y += 0.1;
				这将以每帧（每秒60次）运行，并给立方体一个很好的旋转动画。
			*/
			
//			if (Detector.webgl) {
//		    // Initiate function or other initializations here
//				    animate();
//				} else {
//				    var warning = Detector.getWebGLErrorMessage();
//				    document.getElementById('container').appendChild(warning);
//				}
			animate();
		</script>
	</body>
</html>